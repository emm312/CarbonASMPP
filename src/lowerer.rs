use std::{collections::HashMap, fs::File, io::Write};

use crate::ast::{Program, ProgramBody, InstructionTypes};

pub fn lower(prog: Program, page_label_map: HashMap<String, u8>) {
    let mut lowerer = Lowerer::new(page_label_map);
    lowerer.lower(prog);
}

struct Lowerer {
    pc: usize,
    page_label_map: HashMap<String, u8>,
    label_next_instr: Option<String>,
    output: String,
    page: u8
}

impl Lowerer {
    pub fn new(page_label_map: HashMap<String, u8>) -> Lowerer {
        Lowerer { pc: 0, page_label_map, label_next_instr: None, output: String::new(), page: 0 }
    }

    pub fn lower(&mut self, prog: Program) {
        self.output += "// GENERATED BY THE CARBONASM++ COMPILER\n";
        self.output += ">0\n";
        for line in prog.0 {
            match line {
                ProgramBody::Label(l) => self.label_next_instr = Some(l),
                ProgramBody::Instruction(i) => {
                    match i.opcode {
                        InstructionTypes::Ldi => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("LDI {}", i.operands[0]));
                            self.write_to_output(&format!("{}", i.operands[1]));
                            self.pc += 2;
                        }
                        InstructionTypes::Hlt => {
                            self.reserve_size(1);
                            self.write_to_output("HLT");
                            self.pc += 1;
                        }
                        InstructionTypes::Add => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("ADR {}", i.operands[2]));
                            self.pc += 2;
                        }
                        InstructionTypes::And => {
                            self.reserve_size(3);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("AND {}", i.operands[2]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 3;
                        }
                        InstructionTypes::Brc => {
                            let branch_page = self.page_label_map[&i.operands[0].unwrap_label()];
                            println!("{:#?}", self.page_label_map);
                            if self.page == branch_page {
                                self.reserve_size(3); // reserve an extra word so its not on the boundary
                                self.write_to_output(&format!("BRC {}", i.operands[1]));
                                self.write_to_output(&format!("{}", i.operands[0]));
                            } else {
                                self.reserve_size(5); // reserve an extra word so its not on the boundary
                                self.write_to_output(&format!("LDI R7"));
                                self.write_to_output(&format!("{}", i.operands[0]));
                                self.write_to_output(&format!("ICS {}", i.operands[1]));
                                self.write_to_output(&format!("{}", branch_page));
                                self.pc += 4;    
                            }
                        }
                        InstructionTypes::Cmp => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("RLD {}", i.operands[0]));
                            self.write_to_output(&format!("CMP {}", i.operands[1]));
                            self.pc += 2;
                        }
                        InstructionTypes::Mld => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("MLD {}", i.operands[1]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 2;
                        }
                        InstructionTypes::Mst => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("MST {}", i.operands[0]));
                            self.pc += 2;
                        }
                        InstructionTypes::Nand => {
                            self.reserve_size(3);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("NAND {}", i.operands[2]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 3;
                        }
                        InstructionTypes::Or => {
                            self.reserve_size(3);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("OR {}", i.operands[2]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 3;
                        }
                        InstructionTypes::Sub => {
                            self.reserve_size(3);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("SUB {}", i.operands[2]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 3;
                        }
                        InstructionTypes::Xor => {
                            self.reserve_size(3);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("XOR {}", i.operands[2]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 3;
                        }
                        InstructionTypes::Pld => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("PLD {}", i.operands[1]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 2;
                        }
                        InstructionTypes::Pst => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("PST {}", i.operands[0]));
                            self.pc += 2;
                        }
                        InstructionTypes::Mov => {
                            self.reserve_size(2);
                            self.write_to_output(&format!("RLD {}", i.operands[1]));
                            self.write_to_output(&format!("RST {}", i.operands[0]));
                            self.pc += 2;
                        }
                    }
                }
            }
        }
        File::create("out.carbonasm").unwrap().write_all(self.output.as_bytes()).unwrap();
    }

    pub fn write_to_output(&mut self, s: &str) {
        if (self.pc + 1) % 33 == 0 {
            self.page += 1;
            self.output += &format!(">{}\n", self.page);
        }
        self.output += &s;
        if let Some(l) = &self.label_next_instr {
            self.output += &format!(" {}", l);
            self.label_next_instr = None;
        }
        self.output += "\n";
    }

    pub fn reserve_size(&mut self, size: usize) {
        if (self.pc+1)%33 + size >= 32 {
            for _ in 0..(33-(self.pc+1)%33) {
                self.pc += 1;
                self.output += "NOP\n";
            }
        }
    }
}